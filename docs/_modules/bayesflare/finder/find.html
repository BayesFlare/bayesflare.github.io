

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bayesflare.finder.find &mdash; BayesFlare 1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../../',
        VERSION:'1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="BayesFlare 1 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../index.html" class="icon icon-home"> BayesFlare</a>
        <form class="wy-form" action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">A Brief Introduction to pyFlare</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts.html">Pre-made Scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts.html#pitkin-williams-et-al">Pitkin, Williams, et. al.</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Data Handling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../data.html#module-bayesflare.data.data">Data Loader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#module-bayesflare.models.flare">The Flare Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../models.html#module-bayesflare.models.transit">The Transit Models</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../stats.html">Statistical Operations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../stats.html#module-bayesflare.stats.thresholding">Automatic Thresholder</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../noise.html">Noise Estimation and Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../finder.html">Flare Indentification</a><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../misc.html">Miscellaneous Functions</a></li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">BayesFlare</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../../index.html">Docs</a> &raquo;</li>
  <li><a href="">bayesflare.finder.find</a></li>
  
</ul>
<hr/>

          
  <h1>Source code for bayesflare.finder.find</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">..misc</span> <span class="kn">import</span> <span class="n">mkdir</span>
<span class="kn">from</span> <span class="nn">..noise</span> <span class="kn">import</span> <span class="n">estimate_noise_ps</span><span class="p">,</span> <span class="n">estimate_noise_tv</span>
<span class="kn">from</span> <span class="nn">..models</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">..stats</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">import</span> <span class="nn">pyfits</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>

<div class="viewcode-block" id="contiguous_regions"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.contiguous_regions">[docs]</a><span class="k">def</span> <span class="nf">contiguous_regions</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find contiguous regions for the condition e.g. array &gt; threshold and return</span>
<span class="sd">        a list as two columns of the start and stop indices for each region</span>
<span class="sd">        (see http://stackoverflow.com/a/4495197/1862861)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition : str</span>
<span class="sd">           A test condition (e.g. array &gt; threshold) returning a numpy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">           A two column array containing the start and end indices of</span>
<span class="sd">           contiguous regions obeying the condition.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Find the indicies of changes in &quot;condition&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="c"># We need to start things after the change in &quot;condition&quot;. Therefore,</span>
        <span class="c"># we&#39;ll shift the index by 1 to the right.</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c"># If the start of condition is True prepend a 0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">condition</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># If the end of condition is True, append the length of the array</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">condition</span><span class="o">.</span><span class="n">size</span><span class="p">]</span> <span class="c"># Edit</span>

        <span class="c"># Reshape the result into two columns</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

</div>
<div class="viewcode-block" id="Finder"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder">[docs]</a><span class="k">class</span> <span class="nc">Finder</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operations intended to identify flaring events from the array of Bayesian odds-ratios,</span>
<span class="sd">    and to save the results and the odds-ratios out as a FITS file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bayesfactors : BayesFlare Bayes instance</span>
<span class="sd">       The object holding the odds-ratio information.</span>
<span class="sd">    thresholder : BayesFlare Thresholder instance</span>
<span class="sd">       The object containing the thresholds.</span>
<span class="sd">    results_root : str, optional</span>
<span class="sd">       A file path to the location where results should be output. Defaults to the value of</span>
<span class="sd">       the environmental variable KPLR_RES_ROOT.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bayesfactors</span><span class="p">,</span> <span class="n">thresholder</span><span class="p">,</span> <span class="n">results_root</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results_root</span> <span class="o">=</span> <span class="n">results_root</span>
        <span class="k">if</span> <span class="n">results_root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">results_root</span> <span class="o">=</span> <span class="n">KPLR_RES_ROOT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span> <span class="o">=</span> <span class="n">bayesfactors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholder</span> <span class="o">=</span> <span class="n">thresholder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">()</span>

<div class="viewcode-block" id="Finder.mptaus"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder.mptaus">[docs]</a>    <span class="k">def</span> <span class="nf">mptaus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the most probable set of decay constants at a given location in an array of lnB values</span>
<span class="sd">        marginalised over amplitude.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">           The location index in the array of lnB values to be examined</span>
<span class="sd">        lnBmargAmp : np.ndarray</span>
<span class="sd">           An array of ln(bayes factor) values which have been marginalised over amplitude</span>
<span class="sd">           but not over the decay constants.</span>
<span class="sd">        tausGauss : np.ndarray</span>
<span class="sd">           An array of the gaussian decay constants</span>
<span class="sd">        tausExp : np.ndarray</span>
<span class="sd">           An array of the exponential decay constants</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mptaugauss : float</span>
<span class="sd">           The most probable value for tau gauss.</span>
<span class="sd">        mptauexp : float</span>
<span class="sd">           The most probable value of tau exp.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="s">&#39;flare&#39;</span>
        <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">premarg</span><span class="p">[</span><span class="n">mod</span><span class="p">][:,:,</span><span class="n">i</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">premarg</span><span class="p">[</span><span class="s">&#39;flare&#39;</span><span class="p">][:,:,</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">tausGauss</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tausExp</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mptaugauss</span> <span class="o">=</span> <span class="n">tausGauss</span><span class="p">[</span><span class="n">col1</span><span class="p">]</span><span class="o">/</span><span class="mf">3600.</span>
        <span class="n">mptauexp</span> <span class="o">=</span> <span class="n">tausExp</span><span class="p">[</span><span class="n">col2</span><span class="p">]</span><span class="o">/</span><span class="mf">3600.</span>
        <span class="k">return</span> <span class="n">mptaugauss</span><span class="p">,</span> <span class="n">mptauexp</span>
</div>
<div class="viewcode-block" id="Finder.find"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder.find">[docs]</a>    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The principle flare finding method.</span>
<span class="sd">        Must be run to generate the results table.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresholder</span>

        <span class="n">starti</span> <span class="o">=</span> <span class="n">endi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flares</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
        <span class="n">in_flare</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">T</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">in_flare</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">in_flare</span> <span class="o">=</span> <span class="mi">1</span>         <span class="c"># We&#39;re now in a flare</span>
                    <span class="n">starti</span>   <span class="o">=</span> <span class="n">i</span>         <span class="c"># Note the starting position of the flare detection</span>
                <span class="c"># Otherwise we just go on about our business.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">in_flare</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">in_flare</span> <span class="o">=</span> <span class="mi">0</span>     <span class="c"># We&#39;re now out of the flare</span>
                    <span class="n">endi</span>     <span class="o">=</span> <span class="n">i</span>     <span class="c"># Note the end position of the flare</span>

                    <span class="n">mp</span> <span class="o">=</span> <span class="n">starti</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">[</span><span class="n">starti</span><span class="p">:</span><span class="n">endi</span><span class="p">])</span>
                    <span class="n">ma</span> <span class="o">=</span> <span class="n">starti</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">starti</span><span class="p">:</span><span class="n">endi</span><span class="p">])</span>

                    <span class="n">mp_tau_gauss</span><span class="p">,</span> <span class="n">mp_tau_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mptaus</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>

                    <span class="n">background</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">endi</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">background</span>   <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">starti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">endi</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="k">elif</span> <span class="n">starti</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">background</span>   <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">starti</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">amplitude</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">ma</span><span class="p">]</span> <span class="o">-</span> <span class="n">background</span>
                    <span class="n">damplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">amplitude</span><span class="o">+</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dc</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">background</span><span class="o">+</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dc</span><span class="p">))</span>

                    <span class="n">EW</span>               <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">[</span><span class="n">starti</span><span class="p">:</span><span class="n">endi</span><span class="p">]</span> <span class="o">-</span> <span class="n">background</span> <span class="o">+</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dc</span><span class="p">)</span> <span class="o">/</span> <span class="n">background</span><span class="o">+</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dc</span> <span class="p">)</span>
                    <span class="n">logEW</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">EW</span><span class="p">)</span>

                    <span class="n">g_duration</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.1</span><span class="p">))</span> <span class="o">*</span> <span class="n">mp_tau_gauss</span>
                    <span class="n">e_duration</span>       <span class="o">=</span> <span class="o">-</span> <span class="n">mp_tau_exp</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
                    <span class="n">duration</span>         <span class="o">=</span> <span class="n">e_duration</span> <span class="o">+</span> <span class="n">g_duration</span>

                    <span class="n">confidence</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">bayes_to_confidence</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">[</span><span class="n">mp</span><span class="p">])</span>

                    <span class="n">flare</span>    <span class="o">=</span> <span class="p">[</span><span class="n">starti</span><span class="p">,</span> <span class="n">endi</span><span class="p">,</span> <span class="n">mp_tau_gauss</span><span class="p">,</span> <span class="n">mp_tau_exp</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">damplitude</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">logEW</span><span class="p">,</span> <span class="n">confidence</span><span class="p">]</span>
                    <span class="n">starti</span> <span class="o">=</span> <span class="n">endi</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">,</span> <span class="n">flare</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">flare</span><span class="p">]</span>
                <span class="n">in_flare</span> <span class="o">=</span> <span class="mi">0</span>

</div>
<div class="viewcode-block" id="Finder.star_summary"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder.star_summary">[docs]</a>    <span class="k">def</span> <span class="nf">star_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a summary of the flaring activity of the star, and writes the KIC number of the star to an appropriate file.</span>

<span class="sd">        .. note: At the moment this method isn&#39;t really doing anything, and may be deprecated in the near future.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">quarter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">quarter</span>
        <span class="n">cadence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cadence</span>
        <span class="n">objs</span>  <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">flares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>

        <span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_root</span><span class="p">)</span>
        <span class="c">#sum_file = open(self.results_root+&#39;/quarter&#39;+str(quarter)+&#39;/&#39;+str(cadence)+&#39;/summary/&#39;+object+&#39;.kep&#39;, &#39;w&#39;)</span>

        <span class="c">#pos_file = open(self.results_root + &#39;/flare_stars.kep&#39;, &#39;a&#39;)</span>
        <span class="n">neg_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_root</span> <span class="o">+</span><span class="s">&#39;/normal_stars.kep&#39;</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="c">#mis_file = open(self.results_root +&#39;/missing.kep&#39;, &#39;a&#39;)</span>
        <span class="c">#hsi_file = open(self.results_root +&#39;/high_sigma.kep&#39;, &#39;a&#39;)</span>
        <span class="c">#tra_file = open(self.results_root +&#39;/transit_stars.kep&#39;, &#39;a&#39;)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flares</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">neg_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>

        <span class="n">neg_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Finder.star_vitals"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder.star_vitals">[docs]</a>    <span class="k">def</span> <span class="nf">star_vitals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates summary statistics for the flaring of the star, and outputs it to a file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">quarter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">quarter</span>
        <span class="n">cadence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cadence</span>
        <span class="nb">object</span>  <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="n">flares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flares</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_root</span><span class="o">+</span><span class="s">&#39;/quarter&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">quarter</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cadence</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;/flares&#39;</span><span class="p">)</span>
        <span class="n">det_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_root</span><span class="o">+</span><span class="s">&#39;/quarter&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">quarter</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span><span class="n">cadence</span><span class="o">+</span><span class="s">&#39;/flares/&#39;</span><span class="o">+</span><span class="nb">object</span><span class="o">+</span><span class="s">&#39;.kep&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>

        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;# Start the flaring statistics&#39;</span> <span class="o">+</span> <span class="n">nl</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;# Flaring statistics for KIC&#39;</span> <span class="o">+</span> <span class="nb">object</span> <span class="o">+</span> <span class="n">nl</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;# Total number of flares: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flares</span><span class="p">))</span> <span class="o">+</span><span class="n">nl</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;# ------------------------------------------------------&#39;</span><span class="o">+</span><span class="n">nl</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;# Start </span><span class="se">\t</span><span class="s"> End </span><span class="se">\t</span><span class="s"> MP t_g </span><span class="se">\t</span><span class="s"> MP t_e </span><span class="se">\t</span><span class="s"> Amp </span><span class="se">\t</span><span class="s"> DAmp </span><span class="se">\t</span><span class="s"> Dur </span><span class="se">\t</span><span class="s"> lEW </span><span class="se">\t</span><span class="s"> Conf&#39;</span><span class="o">+</span><span class="n">nl</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">nl</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)):</span>
            <span class="n">det_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">7</span><span class="p">],</span>
                                                                                      <span class="n">flares</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">8</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">flares</span><span class="p">)</span>
        <span class="n">det_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="Finder.save"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.Finder.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method writes the log Bayes factors out to a fits file,</span>
<span class="sd">        along with the header information from the light curve file.</span>
<span class="sd">        The original light curve is stored also.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self : Finder object</span>
<span class="sd">        A Finder object which contains the light curve and the time</span>
<span class="sd">        series of log Bayes factors which are to be written out.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results_root</span>
        <span class="nb">object</span>  <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bayesfactors</span>

        <span class="c"># Prepare the new meta data</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">Header</span><span class="p">()</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;D_LENGTH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">detrend_length</span><span class="p">,</span> <span class="s">&#39;[samples] Detrending window len&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;D_LENGTS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">detrend_length</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dt</span><span class="p">(),</span> <span class="s">&#39;[sec] Detrending window len&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;D_ORDER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">detrend_order</span><span class="p">,</span> <span class="s">&#39;Detrending order&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;THRESH_B&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thresholder</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="s">&#39;[ln Bayes] Thresholding cutoff&#39;</span><span class="p">)</span>
        <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;THRESH_P&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thresholder</span><span class="o">.</span><span class="n">confidence</span><span class="p">,</span> <span class="s">&#39;[pct] Thresholding cutoff&#39;</span><span class="p">)</span>

        <span class="c"># Store the various time series in a TableHDU</span>
        <span class="n">bayes</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;odds&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">)</span>
        <span class="n">lightcurve</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lightcurve&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">)</span>
        <span class="n">data_table</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">new_table</span><span class="p">([</span><span class="n">bayes</span><span class="p">,</span> <span class="n">lightcurve</span><span class="p">,</span> <span class="n">times</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="n">hdr</span><span class="p">)</span>

        <span class="c"># Store the Model parameters from the search into a TableHDU</span>
        <span class="n">model_nos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">model_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">par_nos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">par_mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">par_maxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">par_ints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">model</span><span class="p">)):</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">)):</span>
                    <span class="n">model_nos</span>   <span class="o">+=</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">model_names</span> <span class="o">+=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">identity_type</span><span class="p">()]</span>
                    <span class="n">par_nos</span>     <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">par_mins</span>    <span class="o">+=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">par_maxs</span>    <span class="o">+=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">par_ints</span>    <span class="o">+=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;model_no&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">model_nos</span><span class="p">),</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;model_name&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;10A&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">model_names</span><span class="p">),</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;par_no&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">par_nos</span><span class="p">),</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;par_min&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">par_mins</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;par_max&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">par_maxs</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
            <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;par_qty&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="n">par_ints</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">model_table</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">new_table</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>

        <span class="n">primary</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">hdulist</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">primary</span><span class="p">,</span> <span class="n">data_table</span><span class="p">,</span> <span class="n">model_table</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Store the flare-finding results to a TableHDU</span>
            <span class="k">print</span> <span class="s">&quot;One flare detected&quot;</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;start_time&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;end_time&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mp_t_exp&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mp_t_gau&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;amplitude&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;diff_amplitude&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">]]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;duration&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">6</span><span class="p">]]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;log_EW&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="p">]]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;confidence&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">8</span><span class="p">]],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Percent&#39;</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="n">results_table</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">new_table</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">hdulist</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">primary</span><span class="p">,</span> <span class="n">data_table</span><span class="p">,</span> <span class="n">model_table</span><span class="p">,</span> <span class="n">results_table</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Store the flare-finding results to a TableHDU</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;start_time&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;end_time&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mp_t_exp&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mp_t_gau&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Seconds&#39;</span><span class="p">),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;amplitude&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;diff_amplitude&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;duration&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">6</span><span class="p">]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;log_EW&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">7</span><span class="p">]),</span>
                <span class="n">pyfits</span><span class="o">.</span><span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;confidence&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="n">array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="p">[:,</span><span class="mi">8</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Percent&#39;</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="n">results_table</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">new_table</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">hdulist</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">HDUList</span><span class="p">([</span><span class="n">primary</span><span class="p">,</span> <span class="n">data_table</span><span class="p">,</span> <span class="n">model_table</span><span class="p">,</span> <span class="n">results_table</span><span class="p">])</span>

        <span class="n">hdulist</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">results_root</span><span class="o">+</span><span class="s">&#39;/&#39;</span><span class="o">+</span> <span class="nb">object</span> <span class="o">+</span> <span class="s">&quot;.fits&quot;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="SigmaThresholdMethod"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.SigmaThresholdMethod">[docs]</a><span class="k">class</span> <span class="nc">SigmaThresholdMethod</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Search for points on a lightcurve that cross a threshold that is based on a number of</span>
<span class="sd">    standard deviations calculated from the data. This is the method used in Walkowicz</span>
<span class="sd">    et al (2011), http://arxiv.org/abs/1008.0853.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lightcurve : BayesFlare Lightcurve instance</span>
<span class="sd">       The light curve to be processed.</span>
<span class="sd">    detrendpoly : bool, optional</span>
<span class="sd">       Boolean flag. Set to `True` to use a second-order polynomial to fit the whole curve.</span>
<span class="sd">       Defaults to `False`.</span>
<span class="sd">    detrendmedian : bool, optional</span>
<span class="sd">       Boolean flag. Set to `True` to detrend the Lightcurve using a median filtering technique.</span>
<span class="sd">    noiseestmethod : {None, &#39;powerspectrum&#39;, &#39;tailveto&#39;}, optional</span>
<span class="sd">       The method used to estimate the noise in the light curve. If `None` is chosen the noise will</span>
<span class="sd">       be estimated as the standard deviation of the entire light curve, including any signals.</span>
<span class="sd">       Defaults to `None`.</span>
<span class="sd">    psestfrac : float, optional</span>
<span class="sd">       The fraction of the power spectrum to be used in estimating the noise, if</span>
<span class="sd">       `noiseestmethod==&#39;powerspectrum&#39;`. Defaults to 0.5.</span>
<span class="sd">    tvsigma : float, optional</span>
<span class="sd">       The number of standard deviations giving the cumulative probability</span>
<span class="sd">       to be included in the noise calculation e.g. if sigma=1 then the central</span>
<span class="sd">       68% of the cumulative probability distribution is used.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    estimate_noise_ps : The power spectrum noise estimator.</span>
<span class="sd">    estimate_noise_tv : The tail veto noise estimator.</span>
<span class="sd">    Lightcurve.running_median : The running median detrender.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nflares</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">flarelist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lightcurve</span><span class="p">,</span> <span class="n">detrendpoly</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">detrendmedian</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">psestfrac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">tvsigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="c"># detrend the lightcurve using a 2nd order polynomial fit to the whole curve</span>
        <span class="c"># if required. Also detrend with a running median over 10 hr intervals.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">detrendpoly</span><span class="p">:</span>
            <span class="c"># remove 2nd order polynomial fit</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">detrendmedian</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">running_median</span><span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="p">(</span><span class="mf">10.</span><span class="o">*</span><span class="mf">60.</span><span class="o">*</span><span class="mf">60.</span><span class="p">))</span>

        <span class="c"># get the standard deviation using the outlier removal method or not</span>
        <span class="k">if</span> <span class="n">noiseestmethod</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">noiseestmethod</span> <span class="o">==</span> <span class="s">&#39;powerspectrum&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">estimate_noise_ps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="p">,</span> <span class="n">estfrac</span><span class="o">=</span><span class="n">peestfrac</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">noiseestmethod</span> <span class="o">==</span> <span class="s">&#39;tailveto&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">estimate_noise_tv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">tvsigma</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error... noise estimation method not recognised&quot;</span>

    <span class="k">def</span> <span class="nf">thresholder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigmathresh</span><span class="o">=</span><span class="mf">4.5</span><span class="p">,</span> <span class="n">mincontiguous</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">usemedian</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">removeedges</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c"># output a list of array indices for which the lightcurve is greater than</span>
        <span class="c"># sigmathresh above the mean (default is mean but the median will be used if</span>
        <span class="c"># usemedian=True) for a minimum of mincontiguous contiguous points</span>

        <span class="n">flarelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numcount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">clc</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">clc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">removeedges</span><span class="p">:</span> <span class="c"># remove 5 hours (half the running median window) from either end of the data</span>
            <span class="n">nremove</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">5.</span><span class="o">*</span><span class="mf">60.</span><span class="o">*</span><span class="mf">60.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">dt</span><span class="p">())</span>
            <span class="n">clc</span> <span class="o">=</span> <span class="n">clc</span><span class="p">[</span><span class="n">nremove</span><span class="p">:</span><span class="o">-</span><span class="n">nremove</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nremove</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">usemedian</span><span class="p">:</span>
            <span class="n">clc</span> <span class="o">=</span> <span class="n">clc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">clc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clc</span> <span class="o">=</span> <span class="n">clc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clc</span><span class="p">)</span>

        <span class="n">condition</span> <span class="o">=</span> <span class="n">clc</span> <span class="o">&gt;</span> <span class="n">sigmathresh</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>

        <span class="c"># find contiguous regions</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">contiguous_regions</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">stop</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">mincontiguous</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c"># found a flare!</span>
                <span class="n">flarelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="o">+</span><span class="n">nremove</span><span class="p">,</span> <span class="n">stop</span><span class="o">+</span><span class="n">nremove</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nflares</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flarelist</span> <span class="o">=</span> <span class="n">flarelist</span>

        <span class="k">return</span> <span class="n">flarelist</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)</span> <span class="c"># return list of indices and number of flares</span>

</div>
<div class="viewcode-block" id="OddsRatioDetector"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector">[docs]</a><span class="k">class</span> <span class="nc">OddsRatioDetector</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to produce the odds ratio detection statistic for a flare versus a selection of noise</span>
<span class="sd">    models. The class will also provides thresholding of the log odds ratio for the purpose of</span>
<span class="sd">    flare detection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lightcurve : :class:`Lightcurve`</span>
<span class="sd">        The light curve data in which to search for signal.</span>
<span class="sd">    bglen : int, default: 55</span>
<span class="sd">        The length of the analysis window that slides across the data.</span>
<span class="sd">    bgorder : int, default: 4</span>
<span class="sd">        The order of the polynomial background variations used in the signal and noise models.</span>
<span class="sd">    amppriorrange : list or float, default: [1e6]</span>
<span class="sd">        A list (or single value) giving the span of the amplitude prior for each of the polynomial</span>
<span class="sd">        coefficients in the background variation model, and the range for the signal model</span>
<span class="sd">        amplitude. This assumes the prior is flat within this range.</span>
<span class="sd">    noiseestmethod : string, default: &#39;powerspectrum&#39;</span>
<span class="sd">        The method used to estimate the noise standard deviation of the light curve data.</span>
<span class="sd">    psestfrac : float, default: 0.5</span>
<span class="sd">        If using the &#39;powerspectrum&#39; method of noise estimation (:func:`estimate_noise_ps`) this</span>
<span class="sd">        gives the fraction of the spectrum (starting from the high frequency end) used in the noise</span>
<span class="sd">        estimate. This value can be between 0 and 1.</span>
<span class="sd">    tvsigma : float, default: 1.0</span>
<span class="sd">        If using the &#39;tailveto&#39; method of noise estimation (:func:`estimate_noise_tv`) this given</span>
<span class="sd">        the standard deviation equivalent to the probability volume required for the noise estimate</span>
<span class="sd">        e.g. a value of 1.0 means the estimate is formed from the central 68% of the datas</span>
<span class="sd">        cumulative probability distribution. This value must be greater than 0.</span>
<span class="sd">    flareparams : dict, default: {&#39;taug&#39;: (0, 1.5*60*60, 10), &#39;taue&#39;: (0.5*60*60, 3.*60*60, 10)}</span>
<span class="sd">        A dictionary containing the flare parameters &#39;taue&#39; and &#39;taug&#39; giving tuples of each of</span>
<span class="sd">        their lower and upper values (in seconds) along with the number of grid points spanning that</span>
<span class="sd">        range (if the tuple contains only a single value then this will be the fixed value of that</span>
<span class="sd">        parameter). These will be numerically marginalised over to produce the log odds ratio.</span>
<span class="sd">    noisepoly : bool, default: True</span>
<span class="sd">        If True then the noise model will include a polynomial background variation (with the same</span>
<span class="sd">        length and order as used in the signal model and set by `bglen` and `bgorder`.</span>
<span class="sd">    noiseimpulse : bool, default: True</span>
<span class="sd">        If True then the noise model will include an impulse model (:class:`Impulse`) on top of a</span>
<span class="sd">        polynomial background variation.</span>
<span class="sd">    noiseimpulseparams : dict, default: {&#39;t0&#39;, (0.,)}</span>
<span class="sd">        A dictionary containing the impulse parameters &#39;t0&#39; giving a tuple of its lower, and upper</span>
<span class="sd">        values (in seconds) and the number of grid points spanning that range (if a single value is</span>
<span class="sd">        given in the tuple then the parameter will be fixed at that value). This range will be</span>
<span class="sd">        numerically marginalised over. For the default values `0.` corresponds to the impulse being</span>
<span class="sd">        at the centre of the analysis window.</span>
<span class="sd">    noiseexpdecay : bool, default: True</span>
<span class="sd">        If True then the noise model will include a purely exponential decay model</span>
<span class="sd">        (:class:`Expdecay`) on top of a polynomial background variation.</span>
<span class="sd">    noiseexpdecayparams : dict, default: {&#39;taue&#39;: (0.0, 0.25*60*60, 3)}</span>
<span class="sd">        A dictionary containing the exponential decay parameter &#39;taue&#39; giving a tuples of its lower</span>
<span class="sd">        and upper values (in seconds) and the number of grid points spanning that range (if the</span>
<span class="sd">        tuple contains only a single value then this will be the fixed value of that parameter).</span>
<span class="sd">        This will be numerically marginalised over to produce the log odds ratio.</span>
<span class="sd">    noiseexpdecaywithreverse : bool, default: True</span>
<span class="sd">        If True then the noise model will include an exponential rise model (just the reverse of</span>
<span class="sd">        the exponential decay) on top of a polynomial background variation. This will have the same</span>
<span class="sd">        parameters as defined in `noiseexpdecayparams`.</span>
<span class="sd">    ignoreedges : bool, default: True</span>
<span class="sd">        If this is true then any output log odds ratio will have the initial and final `bglen`/2</span>
<span class="sd">        values removed. This removes values for which the odds ratio has been calculated using</span>
<span class="sd">        fewer data points.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In the future this could be made more generic to allow any model as the signal model,</span>
<span class="sd">        rather than specifically being the flare model. Further noise models could also be added.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">lightcurve</span><span class="p">,</span>
                 <span class="n">bglen</span><span class="o">=</span><span class="mi">55</span><span class="p">,</span>
                 <span class="n">bgorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                 <span class="n">amppriorrange</span><span class="o">=</span><span class="p">[</span><span class="mf">1.e6</span><span class="p">],</span>
                 <span class="n">noiseestmethod</span><span class="o">=</span><span class="s">&#39;powerspectrum&#39;</span><span class="p">,</span>
                 <span class="n">psestfrac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">tvsigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">flareparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;taug&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="s">&#39;taue&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mf">3.</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">)},</span>
                 <span class="n">noisepoly</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">noiseimpulse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">noiseimpulseparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;t0&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,)},</span>
                 <span class="n">noiseexpdecay</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">noiseexpdecayparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;taue&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">3</span><span class="p">)},</span>
                 <span class="n">noiseexpdecaywithreverse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">ignoreedges</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">lightcurve</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bglen</span> <span class="o">=</span> <span class="n">bglen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span> <span class="o">=</span> <span class="n">bgorder</span>

        <span class="c"># set flare ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_flare_params</span><span class="p">(</span><span class="n">flareparams</span><span class="o">=</span><span class="n">flareparams</span><span class="p">)</span>

        <span class="c"># set amplitude priors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_amp_prior_range</span><span class="p">(</span><span class="n">amppriorrange</span><span class="o">=</span><span class="n">amppriorrange</span><span class="p">)</span>

        <span class="c"># set noise estimation method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_noise_est_method</span><span class="p">(</span><span class="n">noiseestmethod</span><span class="o">=</span><span class="n">noiseestmethod</span><span class="p">,</span> <span class="n">psestfrac</span><span class="o">=</span><span class="n">psestfrac</span><span class="p">,</span> <span class="n">tvsigma</span><span class="o">=</span><span class="n">tvsigma</span><span class="p">)</span>

        <span class="c"># set noise models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_noise_poly</span><span class="p">(</span><span class="n">noisepoly</span><span class="o">=</span><span class="n">noisepoly</span><span class="p">)</span> <span class="c"># polynomial background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_noise_impulse</span><span class="p">(</span><span class="n">noiseimpulse</span><span class="o">=</span><span class="n">noiseimpulse</span><span class="p">,</span> <span class="n">noiseimpulseparams</span><span class="o">=</span><span class="n">noiseimpulseparams</span><span class="p">)</span> <span class="c"># impulse background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_noise_expdecay</span><span class="p">(</span><span class="n">noiseexpdecay</span><span class="o">=</span><span class="n">noiseexpdecay</span><span class="p">,</span> <span class="n">noiseexpdecayparams</span><span class="o">=</span><span class="n">noiseexpdecayparams</span><span class="p">,</span> <span class="n">withreverse</span><span class="o">=</span><span class="n">noiseexpdecaywithreverse</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_ignore_edges</span><span class="p">(</span><span class="n">ignoreedges</span><span class="o">=</span><span class="n">ignoreedges</span><span class="p">)</span>

<div class="viewcode-block" id="OddsRatioDetector.set_ignore_edges"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_ignore_edges">[docs]</a>    <span class="k">def</span> <span class="nf">set_ignore_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignoreedges</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set whether to ignore the edges of the odds ratio i.e. points within half the</span>
<span class="sd">        background window of the start and end of the light curve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignoreedges : bool, default: True</span>
<span class="sd">            If True then the ends of the log odds ratio will be ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreedges</span> <span class="o">=</span> <span class="n">ignoreedges</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_flare_params"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_flare_params">[docs]</a>    <span class="k">def</span> <span class="nf">set_flare_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flareparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;taug&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="s">&#39;taue&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mf">3.</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">10</span><span class="p">)}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the Gaussian rise (&#39;taug&#39;) and exponential decay (&#39;taue&#39;) timescale parameters for the</span>
<span class="sd">        flare parameter grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flareparams : dict, default: {&#39;taug&#39;: (0, 1.5*60*60, 10), &#39;taue&#39;: (0.5*60*60, 3.*60*60, 10)}</span>
<span class="sd">            A dictionary of tuples for the parameters &#39;taug&#39; and &#39;taue&#39;. Each must either be a</span>
<span class="sd">            single value of three values for the low end, high end (both in seconds) and number of</span>
<span class="sd">            parameter points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">taug</span> <span class="o">=</span> <span class="n">flareparams</span><span class="p">[</span><span class="s">&#39;taug&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error... no flare &#39;taug&#39; parameter given&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taug</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flare_taug</span> <span class="o">=</span> <span class="p">[</span><span class="n">taug</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">taug</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flare_taug</span> <span class="o">=</span> <span class="p">[</span><span class="n">taug</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">taug</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">taug</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;taug parameters improperly defined&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">taue</span> <span class="o">=</span> <span class="n">flareparams</span><span class="p">[</span><span class="s">&#39;taue&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error... no flare &#39;taue&#39; parameter given&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flare_taue</span> <span class="o">=</span> <span class="p">[</span><span class="n">taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">taue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flare_taue</span> <span class="o">=</span> <span class="p">[</span><span class="n">taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">taue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">taue</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;taug parameters improperly defined&quot;</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_amp_prior_range"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_amp_prior_range">[docs]</a>    <span class="k">def</span> <span class="nf">set_amp_prior_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amppriorrange</span><span class="o">=</span><span class="p">[</span><span class="mf">1.e6</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the amplitude priors for each component of the model with an amplitude that is</span>
<span class="sd">        analytically marginalised over.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amppriorrange : list of floats, default: [1.e6]</span>
<span class="sd">            A list containing one, or all, amplitude prior range values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">amppriorrange</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c"># Convert to a list</span>
            <span class="n">amppriorrange</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">amppriorrange</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span> <span class="o">=</span> <span class="n">amppriorrange</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_noise_est_method"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_noise_est_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_noise_est_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noiseestmethod</span><span class="o">=</span><span class="s">&#39;powerspectrum&#39;</span><span class="p">,</span> <span class="n">psestfrac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">tvsigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the noise estimation method and its parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noiseestmethod : string, default: &#39;powerspectrum&#39;</span>
<span class="sd">            The noise estimation method. Either &#39;powerspectrum&#39; to use :func:`estimate_noise_ps`, or</span>
<span class="sd">            &#39;tailveto&#39; to use :func:`estimate_noise_tv`.</span>
<span class="sd">        psestfrac : float, default: 0.5</span>
<span class="sd">            The fraction of the upper end of the power spectrum to use for the &#39;powerspectrum&#39;</span>
<span class="sd">            method (must be between 0 and 1).</span>
<span class="sd">        tvsigma : float, default: 1.0</span>
<span class="sd">            The number of &#39;standard deviations&#39; corresponding to the central probability volume</span>
<span class="sd">            used in the &#39;tailveto&#39; method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span> <span class="o">=</span> <span class="n">noiseestmethod</span>
        <span class="k">if</span> <span class="n">noiseestmethod</span> <span class="o">==</span> <span class="s">&#39;powerspectrum&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span> <span class="o">=</span> <span class="n">psestfrac</span>
        <span class="k">elif</span> <span class="n">noiseestmethod</span> <span class="o">==</span> <span class="s">&#39;tailveto&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span> <span class="o">=</span> <span class="n">tvsigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Noise estimation method </span><span class="si">%s</span><span class="s"> not recognised&quot;</span> <span class="o">%</span> <span class="n">noiseestmethod</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_noise_poly"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_noise_poly">[docs]</a>    <span class="k">def</span> <span class="nf">set_noise_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noisepoly</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the noise model to include a polynomial background model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noisepoly : bool, default: True</span>
<span class="sd">            Set to True if this model is to be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noisepoly</span> <span class="o">=</span> <span class="n">noisepoly</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_noise_impulse"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_noise_impulse">[docs]</a>    <span class="k">def</span> <span class="nf">set_noise_impulse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noiseimpulse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">noiseimpulseparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;t0&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,)},</span> <span class="n">positive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the noise model to include a delta function impulse (:class:`Impulse`) on a polynomial</span>
<span class="sd">        background variation. Also set the range of times of the impulse, which will be numerically</span>
<span class="sd">        marginalise over.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noiseimpulse : bool, default: True</span>
<span class="sd">            Set to True if this model is used.</span>
<span class="sd">        noiseimpulseparams : dict, default: {&#39;t0&#39;: (0.,)}</span>
<span class="sd">            A dictionary of tuples of the parameter ranges. &#39;t0&#39; is the only allowed parameter. The</span>
<span class="sd">            tuple should either be a single value or three values giving the low end, high end</span>
<span class="sd">            and number of parameter points.</span>
<span class="sd">        positive : bool, default: False</span>
<span class="sd">            If True then only have the impulse amplitude marginalised over positive values.</span>
<span class="sd">            Otherwise it can have either sign and in marginalised between -infinity and infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulse</span> <span class="o">=</span> <span class="n">noiseimpulse</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">noiseimpulseparams</span><span class="p">[</span><span class="s">&#39;t0&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error... no &#39;t0&#39; value specified for impulse.&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulseparams</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulseparams</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Impulse parameters improperly defined&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulsepositive</span> <span class="o">=</span> <span class="n">positive</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.set_noise_expdecay"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.set_noise_expdecay">[docs]</a>    <span class="k">def</span> <span class="nf">set_noise_expdecay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noiseexpdecay</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">noiseexpdecayparams</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;taue&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span> <span class="mi">3</span><span class="p">)},</span> <span class="n">withreverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the noise model to include an exponential decay (and potentially additionally, as an</span>
<span class="sd">        extra noise model, an exponential rise) on top of a polynomial background variation.</span>
<span class="sd">        Also, set the range of the timescale parameter &#39;taue&#39; for the exponential decay (used for</span>
<span class="sd">        both the decay and rise models), which will be analytically marginalised over.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        noiseexpdecay : bool, default: True</span>
<span class="sd">            Set to True if this model is used.</span>
<span class="sd">        noiseexpdecayparams : dict, default: {&#39;taue&#39;: (0.0, 0.25*60*60, 3)}</span>
<span class="sd">            A dictionary of tuples for the parameter &#39;taue&#39;. It must either be a single value of</span>
<span class="sd">            three values for the low end, high end (both in seconds) and number of parameter points.</span>
<span class="sd">        withreverse : bool, default: True</span>
<span class="sd">            Set to true if there should also be an exponential rise model including in the noise</span>
<span class="sd">            model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noiseexpdecay</span> <span class="o">=</span> <span class="n">noiseexpdecay</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noiseexpdecaywithreverse</span> <span class="o">=</span> <span class="n">withreverse</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">taue</span> <span class="o">=</span> <span class="n">noiseexpdecayparams</span><span class="p">[</span><span class="s">&#39;taue&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error... no exponential decay &#39;taue&#39; parameter given&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span> <span class="o">=</span> <span class="p">[</span><span class="n">taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">taue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span> <span class="o">=</span> <span class="p">[</span><span class="n">taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">taue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">taue</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;taug parameters improperly defined&quot;</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.oddsratio"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.oddsratio">[docs]</a>    <span class="k">def</span> <span class="nf">oddsratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a time series of log odds ratio for data containing a flare *and* polynomial background</span>
<span class="sd">        versus a selection of noise models. For the flare and noise models all parameter values</span>
<span class="sd">        (expect the central time of the model) are analytically, or numerically (using the</span>
<span class="sd">        trapezium rule) marginalised over.</span>

<span class="sd">        Each of the noise models, :math:`\\mathcal{O}^{\\textrm noise}_i`, in the denominator of</span>
<span class="sd">        the odds ratio are combined independently, such that</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\mathcal{O} = \\frac{\\mathcal{O}^{\\textrm signal}}{\\sum_i }\\mathcal{O}^{\\textrm</span>
<span class="sd">            noise}_i}</span>

<span class="sd">        where :math:`\\mathcal{O}^{\\textrm signal}` is the signal model.</span>

<span class="sd">        If no noise models are specified then the returned log odds ratio will be for the signal</span>
<span class="sd">        model versus Gaussian noise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># get flare odds ratio</span>
        <span class="n">Mf</span> <span class="o">=</span> <span class="n">Flare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Mf</span><span class="o">.</span><span class="n">set_taus_gauss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flare_taug</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flare_taug</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flare_taug</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">Mf</span><span class="o">.</span><span class="n">set_taus_exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flare_taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flare_taue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">flare_taue</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">Bf</span> <span class="o">=</span> <span class="n">Bayes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="p">,</span> <span class="n">Mf</span><span class="p">)</span>
        <span class="n">Bf</span><span class="o">.</span><span class="n">bayes_factors_marg_poly_bgd</span><span class="p">(</span><span class="n">bglen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="p">,</span>
                                       <span class="n">bgorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span><span class="p">,</span>
                                       <span class="n">amppriorrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span><span class="p">,</span>
                                       <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span><span class="p">,</span>
                                       <span class="n">psestfrac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span><span class="p">,</span>
                                       <span class="n">tvsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span><span class="p">)</span>
        <span class="n">Of</span> <span class="o">=</span> <span class="n">Bf</span><span class="o">.</span><span class="n">marginalise_full</span><span class="p">()</span>

        <span class="n">noiseodds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># get noise odds ratios</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noisepoly</span><span class="p">:</span>
            <span class="n">Bg</span> <span class="o">=</span> <span class="n">Bf</span><span class="o">.</span><span class="n">bayes_factors_marg_poly_bgd_only</span><span class="p">(</span><span class="n">bglen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="p">,</span>
                                                     <span class="n">bgorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span><span class="p">,</span>
                                                     <span class="n">amppriorrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span><span class="p">,</span>
                                                     <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span><span class="p">,</span>
                                                     <span class="n">psestfrac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span><span class="p">,</span>
                                                     <span class="n">tvsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span><span class="p">)</span>

            <span class="n">noiseodds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Bg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulse</span><span class="p">:</span>
            <span class="c"># setup impulse model</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">Impulse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">M</span><span class="o">.</span><span class="n">set_t0s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulseparams</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulseparams</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulseparams</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">Bi</span> <span class="o">=</span> <span class="n">Bayes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
            <span class="n">Bi</span><span class="o">.</span><span class="n">bayes_factors_marg_poly_bgd</span><span class="p">(</span><span class="n">bglen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="p">,</span>
                                           <span class="n">bgorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span><span class="p">,</span>
                                           <span class="n">halfrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseimpulsepositive</span><span class="p">,</span>
                                           <span class="n">amppriorrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span><span class="p">,</span>
                                           <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span><span class="p">,</span>
                                           <span class="n">psestfrac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span><span class="p">,</span>
                                           <span class="n">tvsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span><span class="p">)</span>
            <span class="n">Oi</span> <span class="o">=</span> <span class="n">Bi</span><span class="o">.</span><span class="n">marginalise_full</span><span class="p">()</span>
            <span class="n">noiseodds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Oi</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">M</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseexpdecay</span><span class="p">:</span>
            <span class="c"># setup short flare-like model</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">Expdecay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">M</span><span class="o">.</span><span class="n">set_taus_exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">Be</span> <span class="o">=</span> <span class="n">Bayes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
            <span class="n">Be</span><span class="o">.</span><span class="n">bayes_factors_marg_poly_bgd</span><span class="p">(</span><span class="n">bglen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="p">,</span>
                                           <span class="n">bgorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span><span class="p">,</span>
                                           <span class="n">amppriorrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span><span class="p">,</span>
                                           <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span><span class="p">,</span>
                                           <span class="n">psestfrac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span><span class="p">,</span>
                                           <span class="n">tvsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span><span class="p">)</span>
            <span class="n">Oe</span> <span class="o">=</span> <span class="n">Be</span><span class="o">.</span><span class="n">marginalise_full</span><span class="p">()</span>
            <span class="n">noiseodds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Oe</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">M</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">noiseexpdecaywithreverse</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">Expdecay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">M</span><span class="o">.</span><span class="n">set_taus_exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_expdecay_taue</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">Ber</span> <span class="o">=</span> <span class="n">Bayes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
                <span class="n">Ber</span><span class="o">.</span><span class="n">bayes_factors_marg_poly_bgd</span><span class="p">(</span><span class="n">bglen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="p">,</span>
                                                <span class="n">bgorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bgorder</span><span class="p">,</span>
                                                <span class="n">amppriorrange</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amppriors</span><span class="p">,</span>
                                                <span class="n">noiseestmethod</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">noiseestmethod</span><span class="p">,</span>
                                                <span class="n">psestfrac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">psestfrac</span><span class="p">,</span>
                                                <span class="n">tvsigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tvsigma</span><span class="p">)</span>
                <span class="n">Oer</span> <span class="o">=</span> <span class="n">Ber</span><span class="o">.</span><span class="n">marginalise_full</span><span class="p">()</span>
                <span class="n">noiseodds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Oer</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">M</span>

        <span class="c"># get the total odds ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreedges</span><span class="p">:</span>
            <span class="n">valrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Of</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">)</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bglen</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">[</span><span class="n">valrange</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valrange</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Of</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">))</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lightcurve</span><span class="o">.</span><span class="n">cts</span><span class="p">)</span>

        <span class="n">lnO</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">valrange</span><span class="p">:</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">noiseodds</span><span class="p">:</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="n">logplus</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">lnO</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Of</span><span class="o">.</span><span class="n">lnBmargAmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">denom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lnO</span><span class="p">,</span> <span class="n">ts</span>
</div>
<div class="viewcode-block" id="OddsRatioDetector.thresholder"><a class="viewcode-back" href="../../../finder.html#bayesflare.finder.find.OddsRatioDetector.thresholder">[docs]</a>    <span class="k">def</span> <span class="nf">thresholder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lnO</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnmax</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output an list of array start and end indices for regions where the log odds ratio is</span>
<span class="sd">        greater than a given threshold `thresh`. Regions can be expanded by a given amount to allow</span>
<span class="sd">        close-by regions to be merged.</span>

<span class="sd">        This is used for flare detection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lnO : list or :class:`numpy.array`</span>
<span class="sd">            A time series array of log odds ratios.</span>
<span class="sd">        thresh : float</span>
<span class="sd">            The log odds ratio threshold for &quot;detections&quot;.</span>
<span class="sd">        expand : int, default:0</span>
<span class="sd">            Expand each contiguous above-threshold region by this number of indices at either side.</span>
<span class="sd">            After expansion any overlapping or adjacent regions will be merged into one region.</span>
<span class="sd">        returnmax : bool, default: True</span>
<span class="sd">            If True then return a list of tuples containing the maximum log odds ratio value in each</span>
<span class="sd">            of the &quot;detection&quot; segments and the index of that value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        flarelist : list of tuples</span>
<span class="sd">            A list of tuples of start and end indices of contiguous regions for the &quot;detections&quot;.</span>
<span class="sd">        numflares : int</span>
<span class="sd">            The number of contiguous regions i.e. the number of detected flares.</span>
<span class="sd">        maxlist : list of tuples</span>
<span class="sd">            If `returnmax` is true then this contains a list of tuples with the maximum log</span>
<span class="sd">            odds ratio value in each of the &quot;detection&quot; segments and the index of that value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># find contiguous regions</span>
        <span class="n">flarelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">contiguous_regions</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lnO</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">):</span> <span class="c">#  make sure lnO is a numpy array by copying</span>
           <span class="n">flarelist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>

        <span class="c"># expand segments if required, and then merge any adjacent or overlapping segments</span>
        <span class="k">if</span> <span class="n">expand</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># if only one flare</span>
                <span class="n">segtmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flarelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">expand</span>    <span class="c"># expand the segment</span>
                <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">expand</span>  <span class="c"># expand the segment</span>

                <span class="c"># check if segment now goes out of range and if so correct it</span>
                <span class="k">if</span> <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnO</span><span class="p">):</span>
                    <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnO</span><span class="p">)</span>

                <span class="n">flarelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">segtmp</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">flisttmp</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c"># expand each segment</span>
                <span class="k">for</span> <span class="n">segn</span> <span class="ow">in</span> <span class="n">flarelist</span><span class="p">:</span>
                    <span class="n">segtmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">segn</span><span class="p">)</span>
                    <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">expand</span>
                    <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">expand</span>

                    <span class="c"># check if segment now goes out of range and if so correct it</span>
                    <span class="k">if</span> <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">segtmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnO</span><span class="p">):</span>
                        <span class="n">segtmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnO</span><span class="p">)</span>

                    <span class="n">flisttmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">segtmp</span><span class="p">))</span>

                <span class="n">flarelist</span> <span class="o">=</span> <span class="n">flisttmp</span>

                <span class="c"># with expanded segments now check for overlapping or adjacent segments and merge</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">newsegs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">thisseg</span> <span class="o">=</span> <span class="n">flarelist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)):</span>
                        <span class="n">nextseg</span> <span class="o">=</span> <span class="n">flarelist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">thisseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nextseg</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c"># overlapping or adjacent segment</span>
                            <span class="n">thisseg</span> <span class="o">=</span> <span class="p">(</span><span class="n">thisseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nextseg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="n">newsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisseg</span><span class="p">)</span>

                    <span class="c"># break from loop</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">):</span>
                        <span class="k">break</span>

                <span class="n">flarelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newsegs</span><span class="p">)</span>

        <span class="n">lnOc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lnO</span><span class="p">)</span>

        <span class="c"># return the list of maximum values and indices for the detections</span>
        <span class="k">if</span> <span class="n">returnmax</span><span class="p">:</span>
            <span class="n">maxlist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">segn</span> <span class="ow">in</span> <span class="n">flarelist</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">segn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">segn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">lnOc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
                <span class="n">maxlist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lnOc</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="k">return</span> <span class="n">flarelist</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">),</span> <span class="n">maxlist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flarelist</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flarelist</span><span class="p">)</span> <span class="c"># return list of indices and number of flares</span></div></div>
</pre></div>

          <footer>
  

  <hr/>

  <p>
      &copy; Copyright 2014, Matthew Pitkin, Daniel Williams.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>